use std::ffi::{CStr, CString};
use std::os::raw::{c_char, c_int, c_void};

// Foreign function interface declarations
#[link(name = "kernel", kind = "static")]
#[link(name = "lz4", kind = "static")]
#[link(name = "z", kind = "static")]
#[link(name = "ncurses", kind = "dylib")]
extern "C" {
    fn Sscheme_init(argc: c_int) -> c_int;
    fn Sregister_boot_file(s: *const c_char);
    fn Stop_level_value(s: *const c_char) -> *mut c_void;
    fn Sforeign_symbol(s: *const c_char, ptr: *mut c_void) -> c_int;
    fn Sbuild_heap(s: *const c_char, f: extern "C" fn());
    fn Scall1(caller: *const c_char, code: *const c_void) -> *const c_void;
    fn Sstring_utf8(s: *const c_char, i: i64) -> *const c_void;
}

// Define an empty function to use as our callback
extern "C" fn empty_callback() {
    // This function intentionally left empty
}

fn main() {
    unsafe {
        // Initialize Chez Scheme
        Sscheme_init(0);

        // Register the boot file
        let petite_boot_file =
            CString::new("/home/dman/dataspace/scheme/ta6le/petite.boot").unwrap();
        Sregister_boot_file(petite_boot_file.as_ptr());

        let boot_file = CString::new("/home/dman/dataspace/scheme/ta6le/scheme.boot").unwrap();
        Sregister_boot_file(boot_file.as_ptr());
        Sbuild_heap(std::ptr::null(), empty_callback);

        // Evaluate a Scheme expression
        let expr = CString::new("(+ 2 3)").unwrap();
        let result = Stop_level_value(expr.as_ptr());

        // // Convert the result to a Rust string
        // let result_str = CStr::from_ptr(result as *const c_char).to_string_lossy();

        let caller = CString::new("<me>").unwrap();

        Scall1(caller.as_ptr(), Sstring_utf8(expr.as_ptr(), -1));
        // println!("Result: {}", result_str);

        // // Define a Rust function to be called from Scheme
        // extern "C" fn rust_function(x: c_int) -> c_int {
        //     println!("Called from Scheme with argument: {}", x);
        //     x * 2
        // }

        // // Register the Rust function with Scheme
        // let func_name = CString::new("rust-function").unwrap();
        // Sforeign_symbol(func_name.as_ptr(), rust_function as *mut c_void);

        // // Call the Rust function from Scheme
        // let call_expr = CString::new("(rust-function 21)").unwrap();
        // let call_result = Stop_level_value(call_expr.as_ptr());
        // let call_result_str = CStr::from_ptr(call_result as *const c_char).to_string_lossy();
        // println!(
        //     "Result of calling Rust function from Scheme: {}",
        //     call_result_str
        // );
    }
}
